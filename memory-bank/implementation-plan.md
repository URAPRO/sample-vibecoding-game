# 実装プラン - three.js エンドレスランナー (MVP) - Ver 1.1 (詳細版)

このプランは、GDD Ver 1.0 (MVP) に基づき、`three.js` を用いたエンドレスランナーゲームのMVP開発を、テストを含めた詳細なステップで進めるための手順を示します。

## フェーズ 1: 基本環境のセットアップと表示確認

1.  **1-1. HTML ファイル作成:**
    * `index.html` を作成し、基本的な HTML 構造 (`<!DOCTYPE html>`, `<html>`, `<head>`, `<body>`) を記述します。
    * `<head>` 内に `<meta charset="UTF-8">`, `<meta name="viewport" content="width=device-width, initial-scale=1.0">`, `<title>` を追加します。
    * `<body>` 内に `three.js` の描画ターゲットとなる `<canvas id="gameCanvas"></canvas>` を配置します。
    * **テスト:** ブラウザで `index.html` を開き、タイトルが表示され、空のページが表示されることを確認します。

2.  **1-2. CSS ファイル作成と適用:**
    * `style.css` を作成し、`body` のマージンとパディングをリセットし、`canvas` がウィンドウ全体に表示されるように基本的なスタイル (`width: 100vw; height: 100vh; display: block;`) を適用します。
    * `index.html` の `<head>` 内で `style.css` を読み込みます (`<link rel="stylesheet" href="style.css">`)。
    * **テスト:** ブラウザをリロードし、Canvas がウィンドウ全体を占める（または背景色が変わるなど、スタイルが適用されていることがわかる）ことを確認します。

3.  **1-3. `three.js` ライブラリ読み込み:**
    * `index.html` の `<body>` の最後（`</canvas>` の後）で `three.js` ライブラリを CDN から読み込みます (`<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>`)。
    * **テスト:** ブラウザの開発者コンソールを開き、`three.js` に関する読み込みエラーが出ていないことを確認します。`THREE` オブジェクトがコンソールで利用可能か確認します。

4.  **1-4. JavaScript ファイル作成と読み込み:**
    * `main.js` を作成します。
    * `index.html` の `<body>` の最後、`three.js` の読み込みスクリプトの後に `main.js` を読み込みます (`<script src="main.js"></script>`)。
    * `main.js` 内に簡単な `console.log("Script loaded");` を記述します。
    * **テスト:** ブラウザをリロードし、開発者コンソールに "Script loaded" が表示されることを確認します。

5.  **1-5. `three.js` シーン、カメラ、レンダラー初期化:**
    * `main.js` 内で、`THREE.Scene`, `THREE.PerspectiveCamera`, `THREE.WebGLRenderer` をインスタンス化します。
    * カメラの位置 (`position`) と向き (`lookAt`) を設定します (例: `camera.position.set(0, 5, 10); camera.lookAt(0, 0, 0);`)。
    * レンダラーのサイズをウィンドウサイズに設定し、`document.body` (または特定のコンテナ) に `renderer.domElement` を追加します。
    * **テスト:** ブラウザをリロードし、エラーが発生しないこと、HTML に Canvas 要素が正しく挿入されていることを開発者ツールで確認します。画面はまだ真っ黒またはデフォルトのクリアカラーです。

6.  **1-6. 基本的なライトの追加:**
    * `THREE.AmbientLight` (環境光) と `THREE.DirectionalLight` (指向性ライト) を作成し、シーンに追加します。指向性ライトの位置を設定します。
    * **テスト:** (この時点では視覚的な変化は少ないですが) エラーが発生しないことを確認します。

7.  **1-7. レンダリングループ作成:**
    * `animate` 関数を作成し、その中で `requestAnimationFrame(animate)` と `renderer.render(scene, camera)` を呼び出すようにします。
    * `animate()` を初回呼び出しします。
    * **テスト:** ブラウザをリロードし、エラーが発生せず、毎フレームレンダリングが実行されていること（コンソールにログを一時的に仕込むなどで確認）を確認します。画面にはまだ何も表示されません。

8.  **1-8. ウィンドウリサイズ対応:**
    * `window.addEventListener('resize', ...)` を使用して、ウィンドウサイズが変更されたときにカメラのアスペクト比 (`camera.aspect`) とレンダラーのサイズ (`renderer.setSize`) を更新し、`camera.updateProjectionMatrix()` を呼び出す処理を追加します。
    * **テスト:** ブラウザウィンドウのサイズを変更し、コンソールエラーが発生せず、表示が崩れない（まだ何も表示されていませんが）ことを確認します。

## フェーズ 2: コア要素の実装と確認

9.  **2-1. 地面 (Plane) の作成と表示:**
    * `THREE.PlaneGeometry` と `THREE.MeshBasicMaterial` (または `MeshStandardMaterial`) を使用して地面オブジェクト (`plane`) を作成します。
    * 地面が水平になるように回転 (`plane.rotation.x = -Math.PI / 2;`) させ、シーンに追加します。
    * **テスト:** ブラウザをリロードし、画面に平面が表示されることを確認します。ライトが当たっていれば色が見えるはずです。カメラの位置や角度を調整して見やすいようにします。

10. **2-2. プレイヤー (Cube) の作成と表示:**
    * `THREE.BoxGeometry` と `THREE.MeshBasicMaterial` (色を地面と変える) を使用してプレイヤーオブジェクト (`player`) を作成します。
    * 地面の上に配置されるように Y 座標を設定し (例: `player.position.y = 0.5;` Box の高さが 1 の場合)、初期レーン位置に対応する X, Z 座標を設定してシーンに追加します。
    * **テスト:** ブラウザをリロードし、地面の上に立方体（プレイヤー）が表示されることを確認します。

11. **2-3. レーン定義とプレイヤー初期位置設定:**
    * 4つのレーンの X 座標を定数または変数で定義します (例: `const lanes = [-3, -1, 1, 3];`)。
    * プレイヤーの現在のレーンインデックスを保持する変数 (例: `let currentLane = 1;`) を定義します。
    * プレイヤーの初期 X 座標を `lanes[currentLane]` を使って設定するように修正します。
    * **テスト:** コードを確認し、プレイヤーが意図した初期レーン（例: 左から2番目）に表示されることを確認します。

12. **2-4. キーボード入力による左右レーン移動:**
    * `window.addEventListener('keydown', ...)` を追加します。
    * イベントハンドラ内で、左矢印キー (`ArrowLeft`) が押されたら `currentLane` をデクリメント（ただし 0 未満にならないように）、右矢印キー (`ArrowRight`) が押されたらインクリメント（ただし最大レーン数を超えないように）します。
    * プレイヤーの X 座標 (`player.position.x`) を新しい `lanes[currentLane]` の値に更新します。
    * **テスト:** ブラウザで左右矢印キーを押し、プレイヤーが定義されたレーン間を正しく移動することを確認します。範囲外に移動しないことも確認します。

## フェーズ 3: ゲームメカニクスの実装と確認

13. **3-1. プレイヤーの自動前進 (Z軸移動):**
    * ゲームの速度を定義する定数 (例: `const gameSpeed = 0.1;`) を追加します。
    * `animate` 関数内で、プレイヤーの Z 座標を毎フレーム `gameSpeed` 分だけ減少させる (`player.position.z -= gameSpeed;`) 処理を追加します。
    * **テスト:** ブラウザをリロードし、プレイヤーが画面奥に向かって自動で進んでいくことを確認します。

14. **3-2. カメラの追従:**
    * `animate` 関数内で、カメラの Z 座標もプレイヤーと同じ量だけ減少させる (`camera.position.z -= gameSpeed;`) 処理を追加します。（プレイヤーを固定し、地面と障害物を動かす方法もありますが、まずは簡単な追従から実装）
    * **テスト:** ブラウザをリロードし、プレイヤーが画面中央付近に留まり続け、背景（地面）が流れていくように見えることを確認します。

15. **3-3. 障害物生成関数の作成:**
    * 障害物 (例: `BoxGeometry` を使った `obstacle`) を作成し、指定されたレーン (`laneIndex`) と Z 座標に配置してシーンに追加する関数 `createObstacle(laneIndex, zPos)` を作成します。
    * **テスト:** この関数を直接呼び出し (例: `createObstacle(0, -20);`)、プレイヤーの前方に障害物が正しく生成されることを確認します。

16. **3-4. 障害物管理配列の準備:**
    * シーン内のアクティブな障害物を保持するための配列 `obstacles = []` を用意します。
    * `createObstacle` 関数内で、生成した障害物を `obstacles` 配列に追加するようにします。
    * **テスト:** コードレビュー。

17. **3-5. 一定距離ごとの障害物生成ロジック:**
    * プレイヤーが進んだ距離を追跡する変数、または最後に障害物を生成した Z 座標を記録する変数を導入します。
    * `animate` 関数内で、プレイヤーが一定距離進むごとに（または `player.position.z` が特定の閾値を下回るごとに）、ランダムなレーンを選択し、プレイヤーのはるか前方 (例: `player.position.z - 50`) に `createObstacle` を使って新しい障害物を生成するロジックを追加します。
    * **テスト:** ゲームを実行し、プレイヤーが前進するにつれて、前方に新しい障害物がランダムなレーンに出現し続けることを確認します。

18. **3-6. 画面外（後方）の障害物削除ロジック:**
    * `animate` 関数内で、`obstacles` 配列をループし、各障害物の Z 座標がカメラ（またはプレイヤー）の後方、ある閾値を超えた (`obstacle.position.z > camera.position.z`) かどうかをチェックします。
    * 閾値を超えた障害物を `scene.remove()` でシーンから削除し、`obstacles` 配列からも削除します。配列の要素を削除する際はループのインデックスに注意が必要です（逆順ループなどが有効）。
    * **テスト:** ゲームをしばらく実行し、開発者ツールのシーン情報や `obstacles` 配列の要素数を確認し、古い障害物が適切に削除され、オブジェクト数が無限に増え続けないことを確認します。

19. **3-7. 衝突判定ロジック (Box3):**
    * `animate` 関数内で、プレイヤーのバウンディングボックス (`new THREE.Box3().setFromObject(player)`) を取得します。
    * `obstacles` 配列をループし、各障害物のバウンディングボックス (`new THREE.Box3().setFromObject(obstacle)`) を取得します。
    * プレイヤーの Box3 と障害物の Box3 が `intersectsBox()` メソッドで交差するかどうかをチェックします。
    * **テスト:** 意図的に障害物にプレイヤーを衝突させ、コンソールに衝突ログが出力されることを確認します。衝突していない場合はログが出力されないことを確認します。

## フェーズ 4: ゲームフローと UI の実装・確認

20. **4-1. ゲーム状態変数の導入:**
    * ゲームの状態 (`'initial'`, `'playing'`, `'gameOver'`) を保持する変数 `gameState` を導入し、初期値を `'initial'` に設定します。
    * **テスト:** コードレビュー。

21. **4-2. ゲーム状態に応じた処理分岐:**
    * `animate` 関数内の主要な処理（プレイヤーの前進、障害物の生成・削除、衝突判定など）を `if (gameState === 'playing') { ... }` ブロックで囲みます。
    * キーボード入力のイベントハンドラも `if (gameState === 'playing') { ... }` で囲みます。
    * **テスト:** ゲームを開始しても、`gameState` が `'playing'` になるまでプレイヤーが動かないこと、キー入力が効かないことを確認します。

22. **4-3. UI 要素の準備 (HTML):**
    * `index.html` にスコア表示用の要素 (`<div id="score">Score: 0</div>`) と、ゲームメッセージ表示用の要素 (`<div id="message">Press SPACE to Start</div>`) を追加します。
    * `style.css` でこれらの要素の位置（例: score は右上、message は中央）と基本的なスタイルを設定します。
    * **テスト:** ブラウザをリロードし、初期メッセージとスコア表示が画面の所定の位置に表示されることを確認します。

23. **4-4. ゲーム開始処理 (Space キー):**
    * キーボード入力のイベントハンドラに、`gameState` が `'initial'` の場合にスペースキー (`' '` または `Space`) が押されたら、`gameState` を `'playing'` に変更し、メッセージ表示要素を非表示にする処理を追加します。
    * **テスト:** 初期状態でスペースキーを押し、メッセージが消え、プレイヤーが動き始める（フェーズ 3 が実装されていれば）ことを確認します。

24. **4-5. スコア計算ロジック:**
    * スコアを保持する変数 `score = 0` を用意します。
    * `animate` 関数内の `gameState === 'playing'` ブロックで、フレームごとに（または時間や距離に応じて）`score` をインクリメントする処理を追加します。
    * **テスト:** ゲームプレイ中にスコアが徐々に増加していくことを確認します。

25. **4-6. スコア表示更新:**
    * スコアが更新されるたびに、HTML のスコア表示要素 (`document.getElementById('score')`) の内容 (`innerText` または `textContent`) を更新する処理を追加します。
    * **テスト:** 画面右上のスコア表示が、内部の `score` 変数の値と一致してリアルタイムに更新されることを確認します。

26. **4-7. ゲームオーバー処理:**
    * 衝突判定ロジックで衝突が検知された際に、`gameState` を `'gameOver'` に変更します。
    * `gameState` が `'gameOver'` になった際に一度だけ実行される処理として、メッセージ表示要素に「GAME OVER - Final Score: [最終スコア] - Press R to Restart」といったメッセージを表示する処理を追加します。
    * **テスト:** 障害物に衝突するとプレイヤーの動きが止まり、ゲームオーバーメッセージと最終スコアが表示されることを確認します。

27. **4-8. リスタート処理 (R キー):**
    * キーボード入力のイベントハンドラに、`gameState` が `'gameOver'` の場合に 'R' キー (`'r'` または `'R'`) が押されたら、以下の処理を行うロジックを追加します:
        * `score` を 0 にリセットします。
        * プレイヤーの位置を初期位置 (`player.position.set(...)`) に戻します。
        * `obstacles` 配列内のすべての障害物をシーンから削除し、配列を空にします (`obstacles.forEach(obs => scene.remove(obs)); obstacles = [];`)。
        * `gameState` を `'playing'` (または `'initial'`) に変更します。
        * ゲームオーバーメッセージを非表示にします。
        * スコア表示をリセットします。
    * **テスト:** ゲームオーバー後に 'R' キーを押し、ゲームが初期状態から再開されることを確認します。スコアがリセットされ、障害物がクリアされていることを確認します。

## フェーズ 5: 調整と最終テスト

28. **5-1. パラメータ調整:**
    * ゲームスピード (`gameSpeed`)、レーンの X 座標、障害物の生成頻度、カメラの距離や角度などを調整し、ゲームの難易度やプレイフィールを改善します。
    * **テスト:** 実際にプレイしてみて、速度感や難易度が適切か確認します。

29. **5-2. 総合テスト:**
    * ゲームの開始、プレイ（左右移動、自動前進）、障害物回避、スコア加算、衝突によるゲームオーバー、リスタートの一連の流れがスムーズに動作することを最終確認します。
    * 異なる操作や状況（連続でキーを押す、境界での動作など）も試し、予期せぬ不具合がないか確認します。

---

